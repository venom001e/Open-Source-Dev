import { GeminiService } from '../gemini';
import { IssueAnalysis, CodeSnippet, CodeFix, FixFailure } from '../../types';
import { logger } from '../../utils/logger';
import { z } from 'zod';

export class EngineerAgent {
  constructor() { }

  async generateFix(
    issue: IssueAnalysis,
    snippets: CodeSnippet[],
    language: string,
    previousFailures: FixFailure[] = []
  ): Promise<CodeFix> {
    const model = GeminiService.getModel('gemini-2.0-flash-exp');

    const schema = z.object({
      file: z.string().describe("The file path to modify"),
      content: z.string().describe("The complete new content of the file"),
      explanation: z.string().describe("Brief explanation of the fix"),
    });

    const structuredModel = model.withStructuredOutput(schema as any);

    const prompt = `You are a Senior Principal Engineer. You solve complex bugs with minimal side effects.
    
# Reasoning Step
1. Map the reported issue to the code snippets provided.
2. Identify the root cause (is it a logic error, a typo, or a missing edge case?).
3. Plan the fix: How will this affect other parts of the file?
4. Write the fix.

Issue: ${issue.problem}
Stack: ${language}

Relevant Code Context:
${snippets.map(s => `File: ${s.file}\n\`\`\`\n${s.content}\n\`\`\``).join('\n\n')}

${previousFailures.length > 0 ? `## Previous Attempts Analysis:\n${previousFailures.map(f => `Attempt ${f.attempt} Error: ${f.error}\nDiagnosis: ${f.diagnosis}`).join('\n\n')}` : ''}

Generate the final FIXED code. 
- You MUST provide the COMPLETE file content. 
- Do NOT use placehoders.
- Ensure the fix is robust.`;

    try {
      const result = await structuredModel.invoke(prompt);
      return {
        file: result.file,
        content: result.content,
      };
    } catch (e) {
      logger.warn('API for fix generation failed, using fallback...');
      return {
        file: snippets[0]?.file || "unknown.txt",
        content: "// Dry run fix generated by fallback due to API limits\n" + (snippets[0]?.content || ""),
      };
    }
  }

  async diagnoseFail(fix: CodeFix, testError: string): Promise<string> {
    const model = GeminiService.getModel('gemini-2.0-flash-exp');

    const prompt = `Test failed with this error:

\`\`\`
${testError}
\`\`\`

The code I wrote was:
\`\`\`
${fix.content}
\`\`\`

In ONE sentence, explain:
1. Why this failed
2. What needs to change

Be specific and actionable.`;

    const response = await model.invoke(prompt);
    // LangChain response content can be string or array of parts. For text models it is usually string.
    return typeof response.content === 'string' ? response.content : JSON.stringify(response.content);
  }
}

